package it.evilsocket.dsploit.net.metasploit;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.net.Target;

/**
 * this class store MSF Exploit
 */
public class MsfExploit extends Target.Exploit
{
  private Option[] mOptions = null;
  private Payload[] mPayloads = null;
  private String mFullDescription = null;
  private int mRank = 0;
  private String[] mTargets = null;
  private int mCurrentTarget = 0;
  private int mCurrentPayload = 0;
  private int mVersion = 0;
  private ArrayList<String> mJobs = null;

  public MsfExploit(String name, String url) {
    super(name,url);
    refresh();
  }

  public void refresh() {
    try {
      if((mOptions == null || mOptions.length == 0 || mPayloads == null || mTargets == null) && System.getMsfRpc()!=null) {
        retrieveInfos();
        retrieveOptions();
        retrievePayloads();
      }
    } catch ( IOException e) {
      Logger.error(e.getMessage());
    } catch (RPCClient.MSFException e) {
      Logger.error(mName+": MSFException: "+e.getMessage());
    } finally {
      if(mOptions==null)
        mOptions = new Option[0];
      if(mPayloads==null)
        mPayloads = new Payload[0];
      if(mTargets==null)
        mTargets = new String[0];
    }
  }

  @SuppressWarnings("unchecked")
  private void retrieveOptions() throws IOException, RPCClient.MSFException {
    int i = 0;
    HashMap<String,HashMap<String, Object>> map =  (HashMap<String,HashMap<String, Object>>) System.getMsfRpc().call("module.options", "exploit", mName);
    Iterator<Map.Entry<String,HashMap<String, Object>>> it = map.entrySet().iterator();
    mOptions = new Option[map.size()];
    while(it.hasNext()) {
      Map.Entry<String,HashMap<String,Object>> item = it.next();
      String name = item.getKey();
      mOptions[i] = new Option(name,item.getValue());
      if(name.equals("RHOST"))
        mOptions[i].setValue(System.getCurrentTarget().getAddress().getHostAddress());
      i++;
    }
  }

  @SuppressWarnings("unchecked")
  private void retrieveInfos() throws IOException, RPCClient.MSFException {
    HashMap<String,Object> map = (HashMap<String,Object>) System.getMsfRpc().call("module.info", "exploit", mName);
    Iterator targetIterator = null;
    // use the name as description, mDescription should be quite short
    mDescription=(String)map.get("name");
    // store the real description in the mFullDescription string.
    mFullDescription=(String)map.get("description");
    // remove all newlines and tab chars, android UI will show it in the best way possible.
    mFullDescription = mFullDescription.replace("\n"," ");
    mFullDescription = mFullDescription.replace("\t","");
    // get rank
    mRank = (Integer)map.get("rank");
    //get version
    try {
      mVersion = Integer.parseInt((String)map.get("version"));
    } catch (NumberFormatException e) {
      Logger.error(mDescription + ": " + e.getMessage());
      mVersion = 0;
    }
    // should we take references too ?
    // get targets
    Set<Map.Entry<Integer,String>> targetsSet = ((Map<Integer,String>) map.get("targets")).entrySet();
    targetIterator = targetsSet.iterator();
    mTargets = new String[targetsSet.size()];
    while(targetIterator.hasNext()) {
      Map.Entry<Integer,String> pair = (Map.Entry<Integer, String>) targetIterator.next();
      mTargets[pair.getKey()] = pair.getValue();
      targetIterator.remove();
    }
    mCurrentTarget = (Integer)map.get("default_target");
  }

  @SuppressWarnings("unchecked")
  private void retrievePayloads() throws IOException, RPCClient.MSFException {
    HashMap<String,ArrayList<String>> map = (HashMap<String,ArrayList<String>>) System.getMsfRpc().call("module.compatible_payloads",mName);
    ArrayList<String> payloads = map.get("payloads");
    int i = 0;
    if(payloads==null)
      mPayloads = new Payload[0];
    else {
      mPayloads = new Payload[payloads.size()];
      for(String pName : payloads) {
        mPayloads[i++] = new Payload(pName);
      }
    }
  }

  @SuppressWarnings("unchecked")
  public boolean launch() {
    if(System.getMsfRpc()==null || this.mOptions.length == 0)
      return false;

    try {
      Map<String,Object> options = new HashMap<String, Object>();

      options.put("TARGET",mCurrentTarget);
      options.put("PAYLOAD",mPayloads[mCurrentPayload].toString());
      for(int i = 0; i < mOptions.length; i++)
        options.put(mOptions[i].getName(),mOptions[i].getValue());
      //HACK: reuse options
      options = (Map<String, Object>) System.getMsfRpc().call("module.execute","exploit",mName,options);
      if(options.get("job_id") != null) { // hooray!
        if(mJobs==null) // first time we successfully launch this exploit
          mJobs = new ArrayList<String>();
        mJobs.add((String)options.get("uuid"));
        return true;
      }
    } catch (RPCClient.MSFException e) {
      System.errorLogging(e);
    } catch (IOException e) {
      System.errorLogging(e);
    }
    return false;
  }

  public String[] getTargets() {
    return mTargets;
  }

  public String getCurrentTarget() {
    return mTargets[mCurrentTarget];
  }

  public int getCurrentTargetIndex() {
    return mCurrentTarget;
  }

  public String getFullDescription() {
    return mFullDescription;
  }

  public int getRank() {
    return mRank;
  }

  public int getVersion() {
    return mVersion;
  }

  @Override
  public String toString() {
    return mName.substring(mName.lastIndexOf('/')+1);
  }

  @Override
  public int getDrawableResourceId() {
    return R.drawable.exploit_msf;
  }

  public Option[] getOptions() {
    return mOptions;
  }

  public Payload[] getPayloads() {
    return mPayloads;
  }

  public void setPayload(int index) {
    if(index >= 0 && index < mPayloads.length)
      mCurrentPayload = index;
  }

  public Payload getCurrentPayload() {
    if( mCurrentPayload < mPayloads.length) {
      return mPayloads[mCurrentPayload];
    }else {
      return null;
    }
  }

  public void setTarget(int index) {
    if(index >= 0 && index < mTargets.length)
      this.mCurrentTarget = index;
  }

  public ArrayList<String> getJobs() {
    return mJobs;
  }
}
