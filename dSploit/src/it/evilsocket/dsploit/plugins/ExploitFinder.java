/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.gui.MsfPreferences;
import it.evilsocket.dsploit.gui.dialogs.ChoiceDialog;
import it.evilsocket.dsploit.gui.dialogs.ErrorDialog;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.gui.dialogs.ListChoiceDialog;
import it.evilsocket.dsploit.net.Databases.Exploitdb;
import it.evilsocket.dsploit.net.Databases.Metasploit;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Vulnerability;
import it.evilsocket.dsploit.net.Target.Exploit;
import it.evilsocket.dsploit.net.metasploit.MsfExploit;
import it.evilsocket.dsploit.net.metasploit.Payload;
import it.evilsocket.dsploit.net.metasploit.RPCClient;

public class ExploitFinder extends Plugin
{
  private final static int SEARCH_MSF = 1;
  private final static int SEARCH_EXDB = 2;

  private ToggleButton       mSearchToggleButton = null;
  private ProgressBar	       mSearchProgress = null;
  private ListView 		       mListView = null;
  private Thread			       mThread = null;
  private ExploitAdapter     mAdapter = null;

  private static ExploitFinder UIThread = null;

  public class ExploitAdapter extends ArrayAdapter<Exploit>
  {
    class ExploitHolder
    {
      ImageView  itemImage;
      TextView   itemTitle;
      TextView   itemDescription;
    }

    public ExploitAdapter(  ) {
      super( ExploitFinder.this, R.layout.plugin_exploit_finder_item, System.getCurrentExploits() );
    }

    @Override
    public View getView( int position, View convertView, ViewGroup parent ) {
      View 		 row    = convertView;
      ExploitHolder holder = null;

      if( row == null )
      {
        LayoutInflater inflater = ( LayoutInflater )ExploitFinder.this.getSystemService( Context.LAYOUT_INFLATER_SERVICE );
        row = inflater.inflate( R.layout.plugin_exploit_finder_item , parent, false );

        holder = new ExploitHolder();

        holder.itemImage  	   = ( ImageView )row.findViewById( R.id.itemIcon );
        holder.itemTitle  	   = ( TextView )row.findViewById( R.id.itemTitle );
        holder.itemDescription = ( TextView )row.findViewById( R.id.itemDescription );

        row.setTag(holder);
      }
      else
      {
        holder = ( ExploitHolder )row.getTag();
      }

      Exploit exploit = getItem(position);

      if( exploit instanceof MsfExploit )
      {
        holder.itemTitle.setText
                           (
                             Html.fromHtml
                                    (
                                      "<b>" + exploit.getName()+ "</b>"
                                    )
                           );
      }
      else
        holder.itemTitle.setText( exploit.getName() );

      holder.itemTitle.setTypeface( null, Typeface.NORMAL );
      holder.itemImage.setImageResource( exploit.getDrawableResourceId() );
      holder.itemDescription.setText( exploit.getDescription() );

      return row;
    }
  }

  private OnItemClickListener listener =  new OnItemClickListener(){
  public void onItemClick( AdapterView<?> parent, View v, final int position, long id ) {
    Exploit exp = mAdapter.getItem(position);

    if(exp==null)
      return;

    if(exp instanceof MsfExploit) {
      final MsfExploit msfEx = (MsfExploit)exp;
      final ArrayList<Integer> availableChoices = new ArrayList<Integer>();
      final String[] stringChoices;
      if(System.getMsfRpc()!=null && !System.getMsfRpc().isRemote())
        availableChoices.add(R.string.exploit_launch);
      if(msfEx.getOptions().length > 0)
        availableChoices.add(R.string.exploit_edit_options);
      if(msfEx.getCurrentPayload()!=null)
        availableChoices.add(R.string.payload_edit_settings);
      if(msfEx.getPayloads().length > 1)
        availableChoices.add(R.string.exploit_choose_payload);
      if(msfEx.getTargets().length > 1)
        availableChoices.add(R.string.exploit_choose_target);
      if(msfEx.getUrl()!=null && !msfEx.getUrl().isEmpty())
        availableChoices.add(R.string.open_url);
      if(msfEx.getFullDescription()!=null)
        availableChoices.add(R.string.show_full_description);
      new ListChoiceDialog(R.string.choose_an_option,availableChoices.toArray(new Integer[availableChoices.size()]),ExploitFinder.this, new ChoiceDialog.ChoiceDialogListener() {
        @Override
        public void onChoice(int choice) {
          Intent intent;
          switch (availableChoices.get(choice)) {
            case R.string.exploit_launch:
              if(msfEx.launch())
                Toast.makeText(ExploitFinder.this, "Job started",Toast.LENGTH_SHORT).show();
              else
                Toast.makeText(ExploitFinder.this,"launch failed",Toast.LENGTH_SHORT).show();
              break;
            case R.string.exploit_edit_options:
              intent = new Intent(ExploitFinder.this, MsfPreferences.class);
              System.setCurrentExploit(msfEx);
              ExploitFinder.this.startActivity(intent);
              break;
            case R.string.payload_edit_settings:
              intent = new Intent(ExploitFinder.this, MsfPreferences.class);
              System.setCurrentPayload(msfEx.getCurrentPayload());
              ExploitFinder.this.startActivity(intent);
              break;
            case R.string.exploit_choose_payload:
              new ListChoiceDialog("Choose a payload", msfEx.getPayloads(),ExploitFinder.this, new ChoiceDialog.ChoiceDialogListener() {
                @Override
                public void onChoice(int choice) {
                  msfEx.setPayload(choice);
                }
              }).show();
              break;
            case R.string.exploit_choose_target:
              new ListChoiceDialog("Choose a target", msfEx.getTargets(),ExploitFinder.this, new ChoiceDialog.ChoiceDialogListener() {
                @Override
                public void onChoice(int choice) {
                  msfEx.setTarget(choice);
                }
              }).show();
              break;
            case R.string.show_full_description:
              new ErrorDialog(msfEx.getName(),msfEx.getFullDescription(),ExploitFinder.this).show();
              break;
            case R.string.open_url:
              startActivity(new Intent( Intent.ACTION_VIEW, Uri.parse(msfEx.getUrl())));
              break;
          }
        }
      }).show();
    } else {
      if(exp.getUrl() != null && !exp.getUrl().isEmpty())
        startActivity(new Intent( Intent.ACTION_VIEW, Uri.parse(exp.getUrl())));
    }
  }};

  private int getSearchMask() {
    String  pref = System.getSettings().getString("SEARCH_EXDB","BOTH");
    if(pref.equals("MSF"))
      return SEARCH_MSF;
    else if(pref.equals("EXDB"))
      return SEARCH_EXDB;
    else
      return SEARCH_MSF|SEARCH_EXDB;
  }

  public ExploitFinder() {
    super
    (

      R.string.exploit_finder,
      R.string.exploit_finder_desc,

      new Target.Type[]{ Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_exploit_finder,
      R.drawable.action_exploit_finder
    );
  }

  public interface ExploitFinderReceiver {
    abstract void onExploitFound();
    abstract void onEnd();
  }

  // make a thread that will search for exploits related to one vulnerability
  private Thread makeSearcher(final Vulnerability vuln, final ExploitFinderReceiver receiver, final int searchMask) {
    return new Thread() {

      private final ExploitFinderReceiver mReceiver = receiver;
      private final int mSearchMask = searchMask;

      private void commit(ArrayList<Exploit> res) {

        // add to Target
        for(Exploit e : res)
          System.addExploit(vuln,e);

        if(mReceiver!=null)
          mReceiver.onExploitFound();
      }

      public void run() {
        Exploit ex = null;
        ArrayList<Exploit> mResults = new ArrayList<Exploit>();

        try {
          if(vuln.osvdb_id!=0)
          {
            if( vuln.has_msf_exploit  && (mSearchMask & SEARCH_MSF) != 0)
              ex = Metasploit.search_by_osvdb(vuln.osvdb_id);

            if( ex != null ) {
              mResults.add(ex);
            } else if((mSearchMask & SEARCH_EXDB) != 0) {
              ArrayList<Exploit> exploits = Exploitdb.search_by_osvdb(vuln.osvdb_id);
              if( exploits != null )
                mResults.addAll(exploits);
            }
          }
          if(mResults.size()>0) {
            commit(mResults);
            mResults.clear();
          }

          if(vuln.cve_id!=null)
          {
            // substring remove "CVE-"
            if((mSearchMask & SEARCH_MSF) != 0)
              ex = Metasploit.search_by_cve(vuln.cve_id.substring(4));
            if(ex != null)
              mResults.add(ex);
            else if((mSearchMask & SEARCH_EXDB)!= 0) {
              ArrayList<Exploit> exploits = Exploitdb.search_by_cveid(vuln.cve_id.substring(4));
              if(exploits!=null)
                mResults.addAll(exploits);
            }
          }
          if(mResults.size()>0)
            commit(mResults);
        } catch ( InterruptedException e) {
          // quit!
        }
      }
    };
  }

  public Thread search(final Target target, final ExploitFinderReceiver receiver) {

    // reload search mask
    final int searchMask = getSearchMask();

    return new Thread()
    {
      public void run()
      {
        Thread[] threadPool = new Thread[target.getVulnerabilities().size()];
        int i = 0;
        final int previousCount = target.getExploits().size();

        // fill the thread pool
        for ( final Vulnerability vuln : target.getVulnerabilities()) {
          threadPool[i++]=makeSearcher(vuln, receiver, searchMask);
        }

        // start
        for(i=0;i<threadPool.length;i++)
          threadPool[i].start();

        // join children
        try {
          for(i=0;i<threadPool.length;i++)
            threadPool[i].join();
        } catch (InterruptedException e) {
          for(;i>=0;i--)
            threadPool[i].interrupt();
        }

        if(receiver!=null) {
          receiver.onEnd();
        }
      }
    };
  }

  private void setStartedState( ) {
    mSearchProgress.setVisibility( View.VISIBLE );

    // create main Thread
    mThread = search(System.getCurrentTarget(), new ExploitFinderReceiver() {
      private boolean somethingFound = false;

      @Override
      public void onExploitFound() {
        somethingFound = true;
        ExploitFinder.this.runOnUiThread( new Runnable() {
          @Override
          public void run() {
            mAdapter.notifyDataSetChanged();
          }
        });
      }

      @Override
      public void onEnd() {
        ExploitFinder.this.runOnUiThread( new Runnable() {
          @Override
          public void run()
          {
            mSearchProgress.setVisibility( View.GONE );
            mSearchToggleButton.setChecked(false);
            if(System.getCurrentExploits().size()==0) {
              new FinishDialog( getString(R.string.warning), getString(R.string.no_exploits_found), ExploitFinder.this ).show();
            } else if(!somethingFound) {
              new ErrorDialog( getString(R.string.warning), getString(R.string.no_exploits_found), ExploitFinder.this).show();
            }
          }
        });
      }
    });
    mThread.start();
  }

  private void setStoppedState( ) {
    if(mThread!=null) {
      mThread.interrupt();
      mThread = null;
    }

    mSearchProgress.setVisibility( View.GONE );
    mSearchToggleButton.setChecked(false);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getSupportMenuInflater();
    inflater.inflate(R.menu.exploit_finder, menu);
    return super.onCreateOptionsMenu(menu);
  }

  @Override
  public void onCreate(Bundle savedInstanceState) {
	  SharedPreferences themePrefs = getSharedPreferences("THEME", 0);
		Boolean isDark = themePrefs.getBoolean("isDark", false);
		if (isDark)
			setTheme(R.style.Sherlock___Theme);
		else
			setTheme(R.style.AppTheme);
    super.onCreate(savedInstanceState);

    Target t = System.getCurrentTarget();

    if( !t.hasOpenPorts())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_open_ports), this ).show();

    else if( !t.hasOpenPortsWithService())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_infos_on_target), this ).show();

    else if( !t.hasVulnerabilities())
      new FinishDialog( getString(R.string.warning), getString(R.string.no_vulnerabilities_found), this ).show();

    mSearchToggleButton = ( ToggleButton )findViewById( R.id.searchToggleButton );
    mSearchProgress	   = ( ProgressBar )findViewById( R.id.searchActivity );
    mListView		   = ( ListView )findViewById( android.R.id.list );
    mAdapter		   = new ExploitAdapter();

    UIThread = this;

    mListView.setAdapter( mAdapter );


    mListView.setOnItemClickListener( listener );

    mSearchToggleButton.setOnClickListener( new OnClickListener(){
      @Override
      public void onClick(View v) {
        if(((ToggleButton)v).isChecked())
          setStartedState();
        else
          setStoppedState();
      }}
    );
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
      case R.id.exploit_launch_all:
        return true;
      default:
        return super.onOptionsItemSelected(item);
    }
  }

  @Override
  public void onBackPressed() {
    setStoppedState();
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
  }

  @Override
  public void onRpcChange(RPCClient currentValue) {
    if(UIThread==null)
      return;
    // rebuild view
    if(this!=UIThread) {
      UIThread.onRpcChange(currentValue);
    } else {
      ExploitFinder.this.runOnUiThread(new Runnable() {
        @Override
        public void run() {
          mAdapter.notifyDataSetChanged();
        }
      });
    }
  }
}