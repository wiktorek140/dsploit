/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.SettingsActivity;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Databases.NationalVulnerability;
import it.evilsocket.dsploit.net.Databases.OpenSourcedVulnerability;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Port;
import it.evilsocket.dsploit.net.Target.Vulnerability;

public class VulnerabilityFinder extends Plugin {
	private final static String TAG = "VULNERABILITYFINDER";
  private final static int SEARCH_OSV = 1;
  private final static int SEARCH_CVE = 2;

	private ToggleButton mSearchToggleButton = null;
	private ProgressBar mSearchProgress = null;
	private ExpandableListView mListView = null;
	private ListViewAdapter mAdapter = null;
	private Thread mThread = null;
	private Thread[] mPool = null;
  private boolean             mVersionMatching = true;

	private static Comparator<Vulnerability> sort_by_score = new Comparator<Vulnerability>() {
		@Override
		public int compare(Vulnerability o1, Vulnerability o2) {
			if (o1.severity > o2.severity)
				return -1;

			else if (o1.severity < o2.severity)
				return 1;

			else
				return 0;
		}
	};

	public class ListViewAdapter extends BaseExpandableListAdapter {
		private HashMap<String, ArrayList<Vulnerability>> mGroups = null;
		private Context mContext = null;

		public ListViewAdapter(Context context) {
			mGroups = new HashMap<String, ArrayList<Vulnerability>>();
			mContext = context;
		}

		public void clear() {
			Object[] keys = mGroups.keySet().toArray();

			for (Object key : keys) {
				mGroups.get(key).clear();
			}

			notifyDataSetChanged();
		}

		public boolean hasGroup(String name) {
			return mGroups.containsKey(name);
		}

		public void addGroup(String name) {
			mGroups.put(name, new ArrayList<Vulnerability>());
			notifyDataSetChanged();
		}

		public void addChild(String group, Vulnerability child) {
			if (!hasGroup(group))
				addGroup(group);

			mGroups.get(group).add(child);
			Collections.sort(mGroups.get(group), sort_by_score);

			notifyDataSetChanged();
		}

		private ArrayList<Vulnerability> getGroupAt(int position) {
			return mGroups.get(mGroups.keySet().toArray()[position]);
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
			return getGroupAt(groupPosition).get(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return (groupPosition * 10) + childPosition;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			return getGroupAt(groupPosition).size();
		}

		@Override
		public Object getGroup(int groupPosition) {
			return mGroups.keySet().toArray()[groupPosition];
		}

		@Override
		public int getGroupCount() {
			return mGroups.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded,
				View convertView, ViewGroup parent) {
			TextView row = (TextView) convertView;
			if (row == null)
				row = new TextView(mContext);

			row.setText(getGroup(groupPosition).toString());
			row.setTextSize(15);
			row.setTypeface(Typeface.DEFAULT_BOLD);
			row.setPadding(50, 0, 0, 0);

			return row;
		}

		@Override
		public View getChildView(int groupPosition, int childPosition,
				boolean isLastChild, View convertView, ViewGroup parent) {
			TextView row = (TextView) convertView;
			if (row == null)
				row = new TextView(mContext);

			Vulnerability cve = (Vulnerability) getChild(groupPosition,
					childPosition);

			if (cve == null)
				row.setText(Html.fromHtml(getString(R.string.nothing_found)));
			else
				row.setText(Html.fromHtml("<font color=\"" + cve.getHtmlColor()
						+ "\"><b>" + cve.getIdentifier()
						+ "</b></font> : <small>" + cve.summary + "</small>"));

			row.setPadding(30, 0, 0, 0);

			return row;
		}

		@Override
		public boolean hasStableIds() {
			return true;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}

	public VulnerabilityFinder() {
		super(R.string.vulnerability_finder,
				R.string.vulnerability_finder_desc,

				new Target.Type[] { Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_vulerability_finder,R.drawable.action_exploit);
	}

  private int getSeachMask() {
    String  pref = System.getSettings().getString("SEARCH_OSVDB","BOTH");
    if(pref.equals("OSVDB"))
      return SEARCH_OSV;
    else if(pref.equals("CVE"))
      return SEARCH_CVE;
    else
      return SEARCH_OSV|SEARCH_CVE;
  }

	private void setStartedState() {
		mSearchProgress.setVisibility(View.VISIBLE);
		int i;
    ArrayList<String> searched = new ArrayList<String>();

		mAdapter.clear();
    for(Port p : System.getCurrentTarget().getOpenPorts())
      for(Vulnerability vuln : p.getVulnerabilities())
              mAdapter.addChild(p.service,vuln);

    final int search_mask = getSeachMask();


		mPool = new Thread[System.getCurrentTarget().getOpenPorts().size()];

		i = 0;
		for (final Port port : System.getCurrentTarget().getOpenPorts()) {
      if( port.service != null && !port.service.isEmpty()) {
        final String query = (mVersionMatching ? port.getServiceQueryWithVersion() : port.getServiceQuery());
        if(searched.contains(query))
          continue;
        searched.add(query);

				mPool[i] = new Thread(new Runnable() {

					@Override
					public void run() {
            try {
              ArrayList<Vulnerability> local_results = new ArrayList<Vulnerability>();
              if((search_mask & SEARCH_OSV) != 0)
                local_results.addAll(OpenSourcedVulnerability.search(query));
              if((search_mask & SEARCH_CVE) != 0)
                local_results.addAll(NationalVulnerability.search(query));
              if(local_results.isEmpty())
                return;
              final ArrayList<Vulnerability> UI_food = local_results;
              for( Vulnerability vuln : local_results )
                System.addVulnerability( port, vuln );

							VulnerabilityFinder.this
									.runOnUiThread(new Runnable() {
										@Override
										public void run() {
                  for(Vulnerability vuln : UI_food)
                    mAdapter.addChild( port.service, vuln );
                  mAdapter.notifyDataSetChanged();
										}
									});
            } catch (InterruptedException e) {
              Logger.info("interrupted");
              // quit!
						}
					}
				});
				mPool[i++].start();
			}
		}
		final int j = i; // integer bridge
		mThread = new Thread(new Runnable() {

			@Override
			public void run() {
				int i = j;
				try {
          for(i--;i>=0;i--)
						mPool[i].join();
				} catch (InterruptedException ie) {
          for(;i>=0;i--)
						mPool[i].interrupt();
				}
				mPool = null;
				VulnerabilityFinder.this.runOnUiThread(new Runnable() {
					@Override
					public void run() {
						mSearchToggleButton.setChecked(false);
						mSearchProgress.setVisibility(View.GONE);
					}
				});
			}
		});
		mThread.start();
	}

	private void setStoppedState() {
		try {
			if (mThread != null) {
				mThread.interrupt();
				mThread.join();
			}
		} catch (Exception e) {

		}

		VulnerabilityFinder.this.runOnUiThread(new Runnable() {
			@Override
			public void run() {
				mSearchToggleButton.setChecked(false);
				mSearchProgress.setVisibility(View.GONE);
			}
		});
	}

	public void onCreate(Bundle savedInstanceState) {
		SharedPreferences themePrefs = getSharedPreferences("THEME", 0);
		Boolean isDark = themePrefs.getBoolean("isDark", false);
		if (isDark)
			setTheme(R.style.Sherlock___Theme);
		else
			setTheme(R.style.AppTheme);
		super.onCreate(savedInstanceState);

		if (System.getCurrentTarget().hasOpenPorts() == false)
			new FinishDialog(getString(R.string.warning),
					getString(R.string.no_open_ports), this).show();

		else if (System.getCurrentTarget().hasOpenPortsWithService() == false)
			new FinishDialog(getString(R.string.warning),
					getString(R.string.no_infos_on_target), this).show();

		mSearchToggleButton = (ToggleButton) findViewById(R.id.searchToggleButton);
		mSearchProgress = (ProgressBar) findViewById(R.id.searchActivity);
		mListView = (ExpandableListView) findViewById(R.id.searchListView);
		mAdapter = new ListViewAdapter(this);

		for (Port port : System.getCurrentTarget().getOpenPorts()) {
			if (port.service != null && port.service.isEmpty() == false) {
				mAdapter.addGroup(port.service);
				for (Vulnerability vuln : port.getVulnerabilities())
					mAdapter.addChild(port.service, vuln);
			}
		}

		mListView.setAdapter(mAdapter);
		mListView.setOnChildClickListener(new OnChildClickListener() {
			@Override
			public boolean onChildClick(ExpandableListView parent, View v,
					int groupPosition, int childPosition, long id) {
				Vulnerability vuln = (Vulnerability) mAdapter.getChild(
						groupPosition, childPosition);

				if (vuln != null) {
					String uri = ((vuln.osvdb_id > 0) ? "http://osvdb.org/show/osvdb/"
							: "http://web.nvd.nist.gov/view/vuln/detail?vulnId=")
							+ vuln.getIdentifier();
					Intent browser = new Intent(Intent.ACTION_VIEW, Uri
							.parse(uri));

					startActivity(browser);
				}

				return true;
			}
		});

		for (int i = 0; i < mAdapter.getGroupCount(); i++) {
			mListView.expandGroup(i);
		}

		mSearchToggleButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
        if(((ToggleButton)v).isChecked())
					setStartedState();
        else
          setStoppedState();
      }
		});
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getSupportMenuInflater();
    inflater.inflate(R.menu.vulnerability_finder, menu);
    return super.onCreateOptionsMenu(menu);
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
      case R.id.search_exact_version:
        if(item.isChecked()) {
          item.setChecked(false);
          mVersionMatching=false;
        } else {
          item.setChecked(true);
          mVersionMatching=true;
        }
        return true;
      case R.id.vulnerability_search_performance:
        startActivity(new Intent(VulnerabilityFinder.this, SettingsActivity.class));
        return true;
      default:
        return super.onOptionsItemSelected(item);
    }
	}

	@Override
	public void onBackPressed() {
		setStoppedState();
		super.onBackPressed();
		overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
	}
}