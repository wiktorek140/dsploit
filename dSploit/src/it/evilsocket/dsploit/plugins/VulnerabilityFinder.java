/*
 * This file is part of the dSploit.
 *
 * Copyleft of Simone Margaritelli aka evilsocket <evilsocket@gmail.com>
 *             Massimo Dragano aka tux_mind <massimo.dragano@gmail.com>
 *
 * dSploit is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * dSploit is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dSploit.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.evilsocket.dsploit.plugins;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Typeface;
import android.net.Uri;
import android.os.Bundle;
import android.text.Html;
import android.view.View;
import android.view.ViewGroup;
import android.view.View.OnClickListener;
import android.widget.BaseExpandableListAdapter;
import android.widget.ExpandableListView;
import android.widget.ExpandableListView.OnChildClickListener;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.actionbarsherlock.view.Menu;
import com.actionbarsherlock.view.MenuInflater;
import com.actionbarsherlock.view.MenuItem;

import it.evilsocket.dsploit.R;
import it.evilsocket.dsploit.SettingsActivity;
import it.evilsocket.dsploit.core.Plugin;
import it.evilsocket.dsploit.core.System;
import it.evilsocket.dsploit.core.Logger;
import it.evilsocket.dsploit.gui.dialogs.FinishDialog;
import it.evilsocket.dsploit.net.Databases.NationalVulnerability;
import it.evilsocket.dsploit.net.Databases.OpenSourcedVulnerability;
import it.evilsocket.dsploit.net.Target;
import it.evilsocket.dsploit.net.Target.Port;
import it.evilsocket.dsploit.net.Target.Vulnerability;

public class VulnerabilityFinder extends Plugin {
	private final static String TAG = "VULNERABILITYFINDER";
  private final static int SEARCH_OSV = 1;
  private final static int SEARCH_CVE = 2;

	private ToggleButton mSearchToggleButton = null;
	private ProgressBar mSearchProgress = null;
	private ExpandableListView mListView = null;
	private ListViewAdapter mAdapter = null;
	private Thread mThread = null;
  private boolean             mVersionMatching = true;

	private static Comparator<Vulnerability> sort_by_score = new Comparator<Vulnerability>() {
		@Override
		public int compare(Vulnerability o1, Vulnerability o2) {
			if (o1.severity > o2.severity)
				return -1;

			else if (o1.severity < o2.severity)
				return 1;

			else
				return 0;
		}
	};

	public class ListViewAdapter extends BaseExpandableListAdapter {
		private HashMap<String, ArrayList<Vulnerability>> mGroups = null;
		private Context mContext = null;

		public ListViewAdapter(Context context) {
			mGroups = new HashMap<String, ArrayList<Vulnerability>>();
			mContext = context;
		}

		public void clear() {
			Object[] keys = mGroups.keySet().toArray();

			for (Object key : keys) {
				mGroups.get(key).clear();
			}

			notifyDataSetChanged();
		}

		public boolean hasGroup(String name) {
			return mGroups.containsKey(name);
		}

		public void addGroup(String name) {
			mGroups.put(name, new ArrayList<Vulnerability>());
			notifyDataSetChanged();
		}

		public void addChild(String group, Vulnerability child) {
			if (!hasGroup(group))
				addGroup(group);

			ArrayList<Vulnerability> vulns = mGroups.get(group);
      if(!vulns.contains(child)) {
        vulns.add(child);
        Collections.sort(mGroups.get(group), sort_by_score);

        notifyDataSetChanged();
      }
		}

		private ArrayList<Vulnerability> getGroupAt(int position) {
			return mGroups.get(mGroups.keySet().toArray()[position]);
		}

		@Override
		public Object getChild(int groupPosition, int childPosition) {
			return getGroupAt(groupPosition).get(childPosition);
		}

		@Override
		public long getChildId(int groupPosition, int childPosition) {
			return (groupPosition * 10) + childPosition;
		}

		@Override
		public int getChildrenCount(int groupPosition) {
			return getGroupAt(groupPosition).size();
		}

		@Override
		public Object getGroup(int groupPosition) {
			return mGroups.keySet().toArray()[groupPosition];
		}

		@Override
		public int getGroupCount() {
			return mGroups.size();
		}

		@Override
		public long getGroupId(int groupPosition) {
			return groupPosition;
		}

		@Override
		public View getGroupView(int groupPosition, boolean isExpanded,
				View convertView, ViewGroup parent) {
			TextView row = (TextView) convertView;
			if (row == null)
				row = new TextView(mContext);

			row.setText(getGroup(groupPosition).toString());
			row.setTextSize(15);
			row.setTypeface(Typeface.DEFAULT_BOLD);
			row.setPadding(50, 0, 0, 0);

			return row;
		}

		@Override
		public View getChildView(int groupPosition, int childPosition,
				boolean isLastChild, View convertView, ViewGroup parent) {
			TextView row = (TextView) convertView;
			if (row == null)
				row = new TextView(mContext);

			Vulnerability cve = (Vulnerability) getChild(groupPosition,
					childPosition);

			if (cve == null)
				row.setText(Html.fromHtml(getString(R.string.nothing_found)));
			else
				row.setText(Html.fromHtml("<font color=\"" + cve.getHtmlColor()
						+ "\"><b>" + cve.getIdentifier()
						+ "</b></font> : <small>" + cve.summary + "</small>"));

			row.setPadding(30, 0, 0, 0);

			return row;
		}

		@Override
		public boolean hasStableIds() {
			return true;
		}

		@Override
		public boolean isChildSelectable(int groupPosition, int childPosition) {
			return true;
		}
	}

	public VulnerabilityFinder() {
		super(R.string.vulnerability_finder,
				R.string.vulnerability_finder_desc,

				new Target.Type[] { Target.Type.ENDPOINT, Target.Type.REMOTE },
      R.layout.plugin_vulerability_finder,R.drawable.action_exploit);
	}

  private int getSeachMask() {
    String  pref = System.getSettings().getString("SEARCH_OSVDB","BOTH");
    if(pref.equals("OSVDB"))
      return SEARCH_OSV;
    else if(pref.equals("CVE"))
      return SEARCH_CVE;
    else
      return SEARCH_OSV|SEARCH_CVE;
  }

  public interface VulnerabilityReceiver {
    abstract void onVulnsFound(Vulnerability[] vulns);
    abstract void onEnd();
  }

  public Thread search(final Target target, final VulnerabilityReceiver listener, boolean exactVersionMatch) {
    int i;
    ArrayList<String> searched = new ArrayList<String>();

    final int search_mask = getSeachMask();

    final Thread[] threadPool = new Thread[target.getOpenPorts().size()];

    i = 0;
    for (final Port port : target.getOpenPorts()) {
      if( port.service != null && !port.service.isEmpty()) {
        final String query = (exactVersionMatch ? port.getServiceQueryWithVersion() : port.getServiceQuery());
        if(searched.contains(query))
          continue;
        searched.add(query);

        threadPool[i] = new Thread(new Runnable() {

          @Override
          public void run() {
            try {
              ArrayList<Vulnerability> local_results = new ArrayList<Vulnerability>();
              if((search_mask & SEARCH_OSV) != 0)
                local_results.addAll(OpenSourcedVulnerability.search(query));
              if((search_mask & SEARCH_CVE) != 0)
                local_results.addAll(NationalVulnerability.search(query));
              if(local_results.isEmpty())
                return;

              for( Vulnerability vuln : local_results ) {
                target.addVulnerability(port, vuln);
              }

              if(listener!=null) {
                listener.onVulnsFound(local_results.toArray(new Vulnerability[local_results.size()]));
              }
            } catch (InterruptedException e) {
              Logger.info("interrupted");
              // quit!
            }
          }
        });
        i++;
      }
    }
    final int j = (i - 1); // integer bridge
    return new Thread(new Runnable() {

      @Override
      public void run() {
        int i = j;
        while(i>=0)
          threadPool[i--].start();
        i=j;
        try {
          while(i>=0)
            threadPool[i--].join();
        } catch (InterruptedException ie) {
          while(i>=0)
            threadPool[i--].interrupt();
        }
        if(listener!=null)
          listener.onEnd();
      }
    });
  }

	private void setStartedState() {
		mSearchProgress.setVisibility(View.VISIBLE);

    mAdapter.clear();
    final Target target = System.getCurrentTarget();

    for(Port p : target.getOpenPorts())
      for(Vulnerability vuln : p.getVulnerabilities())
        mAdapter.addChild(p.service,vuln);

    mThread = search(target, new VulnerabilityReceiver() {
      @Override
      public void onVulnsFound(Vulnerability[] vulns) {
        final Vulnerability[] fVulns = vulns;

        VulnerabilityFinder.this.runOnUiThread(new Runnable() {
                  @Override
                  public void run() {
                    for(Vulnerability vuln : fVulns)
                      mAdapter.addChild( vuln.getPort().service, vuln );
                    mAdapter.notifyDataSetChanged();
                  }
                });
      }

      @Override
      public void onEnd() {
        VulnerabilityFinder.this.runOnUiThread(new Runnable() {
          @Override
          public void run() {
            mSearchToggleButton.setChecked(false);
            mSearchProgress.setVisibility(View.GONE);
          }
        });
      }
    }, mVersionMatching);
    mThread.start();
	}

	private void setStoppedState() {
		try {
			if (mThread != null) {
				mThread.interrupt();
				mThread.join();
			}
		} catch (Exception e) {

		}

		VulnerabilityFinder.this.runOnUiThread(new Runnable() {
			@Override
			public void run() {
				mSearchToggleButton.setChecked(false);
				mSearchProgress.setVisibility(View.GONE);
			}
		});
	}

	public void onCreate(Bundle savedInstanceState) {
		SharedPreferences themePrefs = getSharedPreferences("THEME", 0);
		Boolean isDark = themePrefs.getBoolean("isDark", false);
		if (isDark)
			setTheme(R.style.Sherlock___Theme);
		else
			setTheme(R.style.AppTheme);
		super.onCreate(savedInstanceState);

		if (System.getCurrentTarget().hasOpenPorts() == false)
			new FinishDialog(getString(R.string.warning),
					getString(R.string.no_open_ports), this).show();

		else if (System.getCurrentTarget().hasOpenPortsWithService() == false)
			new FinishDialog(getString(R.string.warning),
					getString(R.string.no_infos_on_target), this).show();

		mSearchToggleButton = (ToggleButton) findViewById(R.id.searchToggleButton);
		mSearchProgress = (ProgressBar) findViewById(R.id.searchActivity);
		mListView = (ExpandableListView) findViewById(R.id.searchListView);
		mAdapter = new ListViewAdapter(this);

		for (Port port : System.getCurrentTarget().getOpenPorts()) {
			if (port.service != null && port.service.isEmpty() == false) {
				mAdapter.addGroup(port.service);
				for (Vulnerability vuln : port.getVulnerabilities())
					mAdapter.addChild(port.service, vuln);
			}
		}

		mListView.setAdapter(mAdapter);
		mListView.setOnChildClickListener(new OnChildClickListener() {
			@Override
			public boolean onChildClick(ExpandableListView parent, View v,
					int groupPosition, int childPosition, long id) {
				Vulnerability vuln = (Vulnerability) mAdapter.getChild(
						groupPosition, childPosition);

				if (vuln != null) {
					String uri = ((vuln.osvdb_id > 0) ? "http://osvdb.org/show/osvdb/"
							: "http://web.nvd.nist.gov/view/vuln/detail?vulnId=")
							+ vuln.getIdentifier();
					Intent browser = new Intent(Intent.ACTION_VIEW, Uri
							.parse(uri));

					startActivity(browser);
				}

				return true;
			}
		});

		for (int i = 0; i < mAdapter.getGroupCount(); i++) {
			mListView.expandGroup(i);
		}

		mSearchToggleButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
        if(((ToggleButton)v).isChecked())
					setStartedState();
        else
          setStoppedState();
      }
		});
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu){
    MenuInflater inflater = getSupportMenuInflater();
    inflater.inflate(R.menu.vulnerability_finder, menu);
    return super.onCreateOptionsMenu(menu);
  }

  @Override
  public boolean onOptionsItemSelected(MenuItem item){
    switch (item.getItemId()) {
      case R.id.search_exact_version:
        if(item.isChecked()) {
          item.setChecked(false);
          mVersionMatching=false;
        } else {
          item.setChecked(true);
          mVersionMatching=true;
        }
        return true;
      case R.id.vulnerability_search_performance:
        startActivity(new Intent(VulnerabilityFinder.this, SettingsActivity.class));
        return true;
      default:
        return super.onOptionsItemSelected(item);
    }
	}

	@Override
	public void onBackPressed() {
		setStoppedState();
		super.onBackPressed();
		overridePendingTransition(R.anim.slide_in_left, R.anim.slide_out_left);
	}
}